
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>6. Host Side Coding &#8212; CCPP Technical  documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7. CCPP Code Management" href="CodeManagement.html" />
    <link rel="prev" title="5. Autogenerated Physics Caps" href="AutoGenPhysCaps.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="CodeManagement.html" title="7. CCPP Code Management"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="AutoGenPhysCaps.html" title="5. Autogenerated Physics Caps"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CCPP Technical  documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="host-side-coding">
<span id="id1"></span><h1>6. Host Side Coding<a class="headerlink" href="#host-side-coding" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes the connection of a host model with the pool of <a class="reference internal" href="Glossary.html#term-ccpp-physics"><span class="xref std std-term">CCPP-Physics</span></a> schemes through the <a class="reference internal" href="Glossary.html#term-ccpp-framework"><span class="xref std std-term">CCPP-Framework</span></a>.</p>
<p>In several places, references are made to an Interoperable Physics Driver (IPD). The IPD was originally developed by EMC and later expanded by NOAA GFDL with the goal of connecting GFS physics to various models. A top motivation for its development was the dycore test that led to the selection of FV3 as the dycore for the <a class="reference internal" href="Glossary.html#term-ufs"><span class="xref std std-term">UFS</span></a>. Designed in a fundamentally different way than the <a class="reference internal" href="Glossary.html#term-ccpp"><span class="xref std std-term">CCPP</span></a>, the IPD will be phased out in the near future in favor of the CCPP as a single way to interface with physics in the UFS. To enable a smooth transition, several of the CCPP components must interact with the IPD and, as such, parts of the CCPP code in the UFS currently carry the tag “IPD”.</p>
<div class="section" id="variable-requirements-on-the-host-model-side">
<h2>6.1. Variable Requirements on the Host Model Side<a class="headerlink" href="#variable-requirements-on-the-host-model-side" title="Permalink to this headline">¶</a></h2>
<p>All variables required to communicate between the host model and the physics, as well as to communicate between physics schemes, need to be allocated by the host model. An exception is variables <code class="docutils literal notranslate"><span class="pre">errflg</span></code>, <code class="docutils literal notranslate"><span class="pre">errmsg</span></code>, <code class="docutils literal notranslate"><span class="pre">loop_cnt</span></code>, <code class="docutils literal notranslate"><span class="pre">blk_no</span></code>, and <code class="docutils literal notranslate"><span class="pre">thrd_no</span></code>, which are allocated by the CCPP-Framework, as explained in <a class="reference internal" href="#datastructuretransfer"><span class="std std-numref">Section 6.4.1</span></a>. A list of all variables required for the current pool of physics can be found in <code class="docutils literal notranslate"><span class="pre">ccpp/framework/doc/DevelopersGuide/CCPP_VARIABLES_XYZ.pdf</span></code> (XYZ: SCM, FV3).</p>
<p>At present, only two types of variable definitions are supported by the CCPP-Framework:</p>
<ul class="simple">
<li><p>Standard Fortran variables (character, integer, logical, real) defined in a module or in the main program. For character variables, a fixed length is required. All others can have a kind attribute of a kind type defined by the host model.</p></li>
<li><p>Derived data types (DDTs) defined in a module or the main program. While the use of DDTs as arguments to physics schemes in general is discouraged (see <a class="reference internal" href="CompliantPhysicsParams.html#iovariablerules"><span class="std std-numref">Section 2.2</span></a>), it is perfectly acceptable for the host model to define the variables requested by physics schemes as components of DDTs and pass these components to CCPP by using the correct local_name (e.g., <code class="docutils literal notranslate"><span class="pre">myddt%thecomponentIwant</span></code>; see <a class="reference internal" href="#variabletableshostmodel"><span class="std std-numref">Section 6.2</span></a>.)</p></li>
</ul>
</div>
<div class="section" id="metadata-for-variable-in-the-host-model">
<span id="variabletableshostmodel"></span><h2>6.2. Metadata for Variable in the Host Model<a class="headerlink" href="#metadata-for-variable-in-the-host-model" title="Permalink to this headline">¶</a></h2>
<p>To establish the link between host model variables and physics scheme variables, the host model must provide metadata information similar to those presented in <a class="reference internal" href="CompliantPhysicsParams.html#metadatarules"><span class="std std-numref">Section 2.2</span></a>. The host model can have multiple metadata files (<code class="docutils literal notranslate"><span class="pre">.meta</span></code>) with multiple metadata sections in each file
(<code class="docutils literal notranslate"><span class="pre">[ccpp-arg-table]</span></code>) or just one. The host model Fortran files contain three-line snippets to indicate the location for insertion of the
metadata information contained in the corresponding section in the <code class="docutils literal notranslate"><span class="pre">.meta</span></code> file.</p>
<div class="highlight-fortran notranslate" id="snippetmetadata"><div class="highlight"><pre><span></span><span class="c">!!&gt; \section arg_table_example_vardefs</span>
<span class="c">!! \htmlinclude example_vardefs.html</span>
<span class="c">!!</span>
</pre></div>
</div>
<p>For each variable required by the pool of CCPP-Physics schemes, one and only one entry must exist on the host model side. The connection between a variable in the host model and in the physics scheme is made through its <code class="docutils literal notranslate"><span class="pre">standard_name</span></code>.</p>
<p>The following requirements must be met when defining metadata for variables in the host model (see also <a class="reference internal" href="#example-vardefs"><span class="std std-ref">Listing 6.1</span></a>
and <a class="reference internal" href="#example-vardefs-meta"><span class="std std-ref">Listing 6.2</span></a> for examples of host model metadata).</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">standard_name</span></code> must match that of the target variable in the physics scheme.</p></li>
<li><p>The type, kind, shape and size of the variable (as defined in the host model Fortran code) must match that of the target variable.</p></li>
<li><p>The attributes <code class="docutils literal notranslate"><span class="pre">units</span></code>, <code class="docutils literal notranslate"><span class="pre">rank</span></code>, <code class="docutils literal notranslate"><span class="pre">type</span></code> and <code class="docutils literal notranslate"><span class="pre">kind</span></code> in the host model metadata must match those in the physics scheme metadata.</p></li>
<li><p>The attributes <code class="docutils literal notranslate"><span class="pre">optional</span></code> and <code class="docutils literal notranslate"><span class="pre">intent</span></code> must be set to <code class="docutils literal notranslate"><span class="pre">F</span></code> and <code class="docutils literal notranslate"><span class="pre">none</span></code>, respectively.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">local_name</span></code> of the variable must be set to the name the host model cap uses to refer to the variable.</p></li>
<li><p>The metadata section that exposes a DDT to the CCPP (as opposed to the section that describes the components of a DDT) must be in the same module where the memory for the DDT is allocated. If the DDT is a module variable, then it must be exposed via the module’s metadata section, which must have the same name as the module.</p></li>
<li><p>Metadata sections describing module variables must be placed inside the module.</p></li>
<li><p>Metadata sections describing components of DDTs must be placed immediately before the type definition and have the same name as the DDT.</p></li>
</ul>
<div class="highlight-fortran notranslate" id="example-vardefs"><div class="highlight"><pre><span></span>    <span class="k">module </span><span class="n">example_vardefs</span>

      <span class="k">implicit none</span>

<span class="c">!!&gt; \section arg_table_example_vardefs</span>
<span class="c">!! \htmlinclude example_vardefs.html</span>
<span class="c">!!</span>

      <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span>           <span class="kd">::</span> <span class="n">r15</span> <span class="o">=</span> <span class="nb">selected_real_kind</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
      <span class="kt">integer</span>                      <span class="kd">::</span> <span class="n">ex_int</span>
      <span class="kt">real</span><span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="mi">8</span><span class="p">),</span> <span class="k">dimension</span><span class="p">(:,:)</span> <span class="kd">::</span> <span class="n">ex_real1</span>
      <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>            <span class="kd">::</span> <span class="n">errmsg</span>
      <span class="kt">logical</span>                      <span class="kd">::</span> <span class="n">errflg</span>

<span class="c">!!&gt; \section arg_table_example_ddt</span>
<span class="c">!! \htmlinclude example_ddt.html</span>
<span class="c">!!</span>

      <span class="k">type </span><span class="n">ex_ddt</span>
        <span class="kt">logical</span>              <span class="kd">::</span> <span class="n">l</span>
        <span class="kt">real</span><span class="p">,</span> <span class="k">dimension</span><span class="p">(:,:)</span> <span class="kd">::</span> <span class="n">r</span>
      <span class="k">end type </span><span class="n">ex_ddt</span>

      <span class="k">type</span><span class="p">(</span><span class="n">ex_ddt</span><span class="p">)</span> <span class="kd">::</span> <span class="n">ext</span>

    <span class="k">end module </span><span class="n">example_vardefs</span>
</pre></div>
</div>
<p><em>Listing 6.1: Example host model file with reference to metadata. In this example, both the definition and the declaration (memory allocation) of a DDT</em> <code class="docutils literal notranslate"><span class="pre">ext</span></code> <em>(of type</em> <code class="docutils literal notranslate"><span class="pre">ex_ddt</span></code> <em>) are in the same module.</em></p>
<div class="highlight-fortran notranslate" id="example-vardefs-meta"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">ccpp</span><span class="o">-</span><span class="n">arg</span><span class="o">-</span><span class="n">table</span><span class="p">]</span>
  <span class="n">name</span> <span class="o">=</span> <span class="n">arg_table_example_vardefs</span>
  <span class="k">type</span> <span class="o">=</span> <span class="k">module</span>
<span class="p">[</span><span class="n">ex_int</span><span class="p">]</span>
  <span class="n">standard_name</span> <span class="o">=</span> <span class="n">example_int</span>
  <span class="n">long_name</span> <span class="o">=</span> <span class="n">ex</span><span class="p">.</span> <span class="nb">int</span>
<span class="nb">  </span><span class="n">units</span> <span class="o">=</span> <span class="k">none</span>
<span class="k">  </span><span class="n">dimensions</span> <span class="o">=</span> <span class="p">()</span>
  <span class="k">type</span> <span class="o">=</span> <span class="kt">integer</span>
<span class="kt">  </span><span class="nb">kind</span> <span class="o">=</span>
<span class="p">[</span><span class="n">ex_real</span><span class="p">]</span>
  <span class="n">standard_name</span> <span class="o">=</span> <span class="n">example_real</span>
  <span class="n">long_name</span> <span class="o">=</span> <span class="n">ex</span><span class="p">.</span> <span class="kt">real</span>
<span class="kt">  </span><span class="n">units</span> <span class="o">=</span> <span class="n">m</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="p">(</span><span class="n">horizontal_dimension</span><span class="p">,</span><span class="n">vertical_dimension</span><span class="p">)</span>
  <span class="k">type</span> <span class="o">=</span> <span class="kt">real</span>
<span class="kt">  </span><span class="nb">kind</span> <span class="o">=</span> <span class="nb">kind</span><span class="o">=</span><span class="mi">8</span>
<span class="p">[</span><span class="n">ex_ddt</span><span class="p">]</span>
  <span class="n">standard_name</span> <span class="o">=</span> <span class="n">example_ddt</span>
  <span class="n">long_name</span> <span class="o">=</span> <span class="n">ex</span><span class="p">.</span> <span class="n">ddt</span>
  <span class="n">units</span> <span class="o">=</span> <span class="n">DDT</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="p">(</span><span class="n">horizontal_dimension</span><span class="p">,</span><span class="n">vertical_dimension</span><span class="p">)</span>
  <span class="k">type</span> <span class="o">=</span> <span class="n">ex_ddt</span>
  <span class="nb">kind</span> <span class="o">=</span>
<span class="p">[</span><span class="n">ext</span><span class="p">]</span>
  <span class="n">standard_name</span> <span class="o">=</span> <span class="n">example_ddt_instance</span>
  <span class="n">long_name</span> <span class="o">=</span> <span class="n">ex</span><span class="p">.</span> <span class="n">ddt</span> <span class="n">inst</span>
  <span class="n">units</span> <span class="o">=</span> <span class="n">DDT</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="p">(</span><span class="n">horizontal_dimension</span><span class="p">,</span><span class="n">vertical_dimension</span><span class="p">)</span>
  <span class="k">type</span> <span class="o">=</span> <span class="n">ex_ddt</span>
  <span class="nb">kind</span> <span class="o">=</span>
<span class="p">[</span><span class="n">errmsg</span><span class="p">]</span>
  <span class="n">standard_name</span> <span class="o">=</span> <span class="n">ccpp_error_message</span>
  <span class="n">long_name</span> <span class="o">=</span> <span class="n">error</span> <span class="n">message</span> <span class="n">for</span> <span class="n">error</span> <span class="n">handling</span> <span class="n">in</span> <span class="n">CCPP</span>
  <span class="n">units</span> <span class="o">=</span> <span class="k">none</span>
<span class="k">  </span><span class="n">dimensions</span> <span class="o">=</span> <span class="p">()</span>
  <span class="k">type</span> <span class="o">=</span> <span class="kt">character</span>
<span class="kt">  </span><span class="nb">kind</span> <span class="o">=</span> <span class="nb">len</span><span class="o">=</span><span class="mi">64</span>
<span class="p">[</span><span class="n">errflg</span><span class="p">]</span>
  <span class="n">standard_name</span> <span class="o">=</span> <span class="n">ccpp_error_flag</span>
  <span class="n">long_name</span> <span class="o">=</span> <span class="n">error</span> <span class="n">flag</span> <span class="n">for</span> <span class="n">error</span> <span class="n">handling</span> <span class="n">in</span> <span class="n">CCPP</span>
  <span class="n">units</span> <span class="o">=</span> <span class="n">flag</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="p">()</span>
  <span class="k">type</span> <span class="o">=</span> <span class="kt">integer</span>

<span class="cp">########################################################################</span>
<span class="p">[</span><span class="n">ccpp</span><span class="o">-</span><span class="n">arg</span><span class="o">-</span><span class="n">table</span><span class="p">]</span>
  <span class="n">name</span> <span class="o">=</span> <span class="n">arg_table_example_ddt</span>
  <span class="k">type</span> <span class="o">=</span> <span class="n">ddt</span>
<span class="p">[</span><span class="n">ext</span><span class="p">%</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">standard_name</span> <span class="o">=</span> <span class="n">example_flag</span>
  <span class="n">long_name</span> <span class="o">=</span> <span class="n">ex</span><span class="p">.</span> <span class="n">flag</span>
  <span class="n">units</span> <span class="o">=</span> <span class="n">flag</span>
  <span class="n">dimensions</span> <span class="o">=</span>
  <span class="k">type</span> <span class="o">=</span> <span class="kt">logical</span>
<span class="kt">  </span><span class="nb">kind</span> <span class="o">=</span>
<span class="p">[</span><span class="n">ext</span><span class="p">%</span><span class="n">r</span><span class="p">]</span>
  <span class="n">standard_name</span> <span class="o">=</span> <span class="n">example_real3</span>
  <span class="n">long_name</span> <span class="o">=</span> <span class="n">ex</span><span class="p">.</span> <span class="kt">real</span>
<span class="kt">  </span><span class="n">units</span> <span class="o">=</span> <span class="n">kg</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="p">(</span><span class="n">horizontal_dimension</span><span class="p">,</span><span class="n">vertical_dimension</span><span class="p">)</span>
  <span class="k">type</span> <span class="o">=</span> <span class="kt">real</span>
<span class="kt">  </span><span class="nb">kind</span> <span class="o">=</span> <span class="n">r15</span>
<span class="p">[</span><span class="n">ext</span><span class="p">%</span><span class="n">r</span><span class="p">(;,</span><span class="mi">1</span><span class="p">)]</span>
  <span class="n">standard_name</span> <span class="o">=</span> <span class="n">example_slice</span>
  <span class="n">long_name</span> <span class="o">=</span> <span class="n">ex</span><span class="p">.</span> <span class="n">slice</span>
  <span class="n">units</span> <span class="o">=</span> <span class="n">kg</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="p">(</span><span class="n">horizontal_dimension</span><span class="p">,</span><span class="n">vertical_dimension</span><span class="p">)</span>
  <span class="k">type</span> <span class="o">=</span> <span class="kt">real</span>
<span class="kt">  </span><span class="nb">kind</span> <span class="o">=</span> <span class="n">r15</span>
</pre></div>
</div>
<p><em>Listing 6.2: Example host model metadata file (</em> <code class="docutils literal notranslate"><span class="pre">.meta</span></code> <em>).</em></p>
</div>
<div class="section" id="ccpp-variables-in-the-scm-and-ufs-atmosphere-host-models">
<h2>6.3. CCPP Variables in the SCM and UFS Atmosphere Host Models<a class="headerlink" href="#ccpp-variables-in-the-scm-and-ufs-atmosphere-host-models" title="Permalink to this headline">¶</a></h2>
<p>While the use of standard Fortran variables is preferred, in the current implementation of the CCPP in the UFS Atmosphere and in the SCM almost all data is contained in DDTs for organizational purposes. In the case of the SCM, DDTs are defined in <code class="docutils literal notranslate"><span class="pre">gmtb_scm_type_defs.f90</span></code> and <code class="docutils literal notranslate"><span class="pre">GFS_typedefs.F90</span></code>, and in the case of the UFS Atmosphere, they are defined in both <code class="docutils literal notranslate"><span class="pre">GFS_typedefs.F90</span></code> and <code class="docutils literal notranslate"><span class="pre">CCPP_typedefs.F90</span></code>.  The current implementation of the CCPP in both host models uses the following set of DDTs:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">GFS_init_type</span></code>             variables to allow proper initialization of GFS physics</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GFS_statein_type</span></code>  prognostic state data provided by dycore to physics</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GFS_stateout_type</span></code> prognostic state after physical parameterizations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GFS_sfcprop_type</span></code>  surface properties read in and/or updated by climatology, obs, physics</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GFS_coupling_type</span></code> fields from/to coupling with other components, e.g., land/ice/ocean</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GFS_control_type</span></code>  control parameters input from a namelist and/or derived from others</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GFS_grid_type</span></code>             grid data needed for interpolations and length-scale calculations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GFS_tbd_type</span></code>              data not yet assigned to a defined container</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GFS_cldprop_type</span></code>  cloud properties and tendencies needed by radiation from physics</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GFS_radtend_type</span></code>  radiation tendencies needed by physics</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GFS_diag_type</span></code>             fields targeted for diagnostic output to disk</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GFS_interstitial_type</span></code>     fields used to communicate variables among schemes in the slow physics group required to replace interstitial code in <code class="docutils literal notranslate"><span class="pre">GFS_{physics,</span> <span class="pre">radiation}_driver.F90</span></code> in CCPP</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GFS_data_type</span></code>     combined type of all of the above except <code class="docutils literal notranslate"><span class="pre">GFS_control_type</span></code> and <code class="docutils literal notranslate"><span class="pre">GFS_interstitial_type</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CCPP_interstitial_type</span></code> fields used to communicate variables among schemes in the fast physics group</p></li>
</ul>
<p>The DDT descriptions provide an idea of what physics variables go into which data type.  <code class="docutils literal notranslate"><span class="pre">GFS_diag_type</span></code> can contain variables that accumulate over a certain amount of time and are then zeroed out. Variables that require persistence from one timestep to another should not be included in the <code class="docutils literal notranslate"><span class="pre">GFS_diag_type</span></code> nor the <code class="docutils literal notranslate"><span class="pre">GFS_interstitial_type</span></code> DDTs. Similarly, variables that need to be shared between groups cannot be included in the <code class="docutils literal notranslate"><span class="pre">GFS_interstitial_type</span></code> DDT. Although this memory management is somewhat arbitrary, new variables provided by the host model or derived in an interstitial scheme should be put in a DDT with other similar variables.</p>
<p>Each DDT contains a create method that allocates the data defined using the metadata. For example, the <code class="docutils literal notranslate"><span class="pre">GFS_stateout_type</span></code> contains:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">type </span><span class="n">GFS_stateout_type</span>

   <span class="c">!-- Out (physics only)</span>
   <span class="kt">real</span> <span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="n">kind_phys</span><span class="p">),</span> <span class="k">pointer</span> <span class="kd">::</span> <span class="n">gu0</span> <span class="p">(:,:)</span>   <span class="o">=&gt;</span> <span class="nb">null</span><span class="p">()</span>  <span class="c">!&lt; updated zonal wind</span>
   <span class="kt">real</span> <span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="n">kind_phys</span><span class="p">),</span> <span class="k">pointer</span> <span class="kd">::</span> <span class="n">gv0</span> <span class="p">(:,:)</span>   <span class="o">=&gt;</span> <span class="nb">null</span><span class="p">()</span>  <span class="c">!&lt; updated meridional wind</span>
   <span class="kt">real</span> <span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="n">kind_phys</span><span class="p">),</span> <span class="k">pointer</span> <span class="kd">::</span> <span class="n">gt0</span> <span class="p">(:,:)</span>   <span class="o">=&gt;</span> <span class="nb">null</span><span class="p">()</span>  <span class="c">!&lt; updated temperature</span>
   <span class="kt">real</span> <span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="n">kind_phys</span><span class="p">),</span> <span class="k">pointer</span> <span class="kd">::</span> <span class="n">gq0</span> <span class="p">(:,:,:)</span> <span class="o">=&gt;</span> <span class="nb">null</span><span class="p">()</span>  <span class="c">!&lt; updated tracers</span>

   <span class="k">contains</span>
<span class="k">     procedure</span> <span class="kd">::</span> <span class="n">create</span>  <span class="o">=&gt;</span> <span class="n">stateout_create</span>  <span class="c">!&lt;   allocate array data</span>
 <span class="k">end type </span><span class="n">GFS_stateout_type</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">gu0</span></code>, <code class="docutils literal notranslate"><span class="pre">gv0</span></code>, <code class="docutils literal notranslate"><span class="pre">gt0</span></code>, and <code class="docutils literal notranslate"><span class="pre">gq0</span></code> are defined in the host-side metadata section, and when the subroutine <code class="docutils literal notranslate"><span class="pre">stateout_create</span></code> is called, these arrays are allocated and initialized to zero.  With the CCPP, it is possible to not only refer to components of DDTs, but also to slices of arrays with provided metadata as long as these are contiguous in memory. An example of an array slice from the <code class="docutils literal notranslate"><span class="pre">GFS_stateout_type</span></code> looks like:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">ccpp</span><span class="o">-</span><span class="n">arg</span><span class="o">-</span><span class="n">table</span><span class="p">]</span>
  <span class="n">name</span> <span class="o">=</span> <span class="n">GFS_stateout_type</span>
  <span class="k">type</span> <span class="o">=</span> <span class="n">ddt</span>
<span class="p">[</span><span class="n">gq0</span><span class="p">(:,:,</span><span class="n">index_for_snow_water</span><span class="p">)]</span>
  <span class="n">standard_name</span> <span class="o">=</span> <span class="n">snow_water_mixing_ratio_updated_by_physics</span>
  <span class="n">long_name</span> <span class="o">=</span> <span class="n">moist</span> <span class="p">(</span><span class="n">dry</span><span class="o">+</span><span class="n">vapor</span><span class="p">,</span> <span class="n">no</span> <span class="n">condensates</span><span class="p">)</span> <span class="n">mixing</span> <span class="n">ratio</span> <span class="n">of</span> <span class="n">snow</span> <span class="n">water</span> <span class="n">updated</span> <span class="n">by</span> <span class="n">physics</span>
  <span class="n">units</span> <span class="o">=</span> <span class="n">kg</span> <span class="n">kg</span><span class="o">-</span><span class="mi">1</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="p">(</span><span class="n">horizontal_dimension</span><span class="p">,</span><span class="n">vertical_dimension</span><span class="p">)</span>
  <span class="k">type</span> <span class="o">=</span> <span class="kt">real</span>
<span class="kt">  </span><span class="nb">kind</span> <span class="o">=</span> <span class="n">kind_phys</span>
</pre></div>
</div>
<p>Array slices can be used by physics schemes that only require certain values from an array.</p>
</div>
<div class="section" id="ccpp-api">
<span id="id2"></span><h2>6.4. CCPP API<a class="headerlink" href="#ccpp-api" title="Permalink to this headline">¶</a></h2>
<p>The CCPP Application Programming Interface (API) is comprised of a set of clearly defined methods used to communicate variables between the host model and the physics and to run the physics. The bulk of the CCPP API is located in the CCPP-Framework, and is described in file <code class="docutils literal notranslate"><span class="pre">ccpp_api.F90</span></code>. Some aspects of the API differ between the dynamic and static build. In particular, subroutines <code class="docutils literal notranslate"><span class="pre">ccpp_physics_init</span></code>, <code class="docutils literal notranslate"><span class="pre">ccpp_physics_finalize</span></code>, and <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run</span></code> (described below) are made public from <code class="docutils literal notranslate"><span class="pre">ccpp_api.F90</span></code> for the dynamic build, and are contained in <code class="docutils literal notranslate"><span class="pre">ccpp_static_api.F90</span></code> for the static build. Moreover, these subroutines take an additional argument (<code class="docutils literal notranslate"><span class="pre">suite_name</span></code>) for the static build. File <code class="docutils literal notranslate"><span class="pre">ccpp_static_api.F90</span></code> is auto-generated when the script <code class="docutils literal notranslate"><span class="pre">ccpp_prebuild.py</span></code> is run for the static build.</p>
<div class="section" id="data-structure-to-transfer-variables-between-dynamics-and-physics">
<span id="datastructuretransfer"></span><h3>6.4.1. Data Structure to Transfer Variables between Dynamics and Physics<a class="headerlink" href="#data-structure-to-transfer-variables-between-dynamics-and-physics" title="Permalink to this headline">¶</a></h3>
<p>The roles of <code class="docutils literal notranslate"><span class="pre">cdata</span></code> structure in dealing with data exchange are not the same between the dynamic and the static builds of the CCPP. For the dynamic build, the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> structure handles the data exchange between the host model and the physics schemes. <code class="docutils literal notranslate"><span class="pre">cdata</span></code> is a DDT containing a list of pointers to variables and their metadata and is persistent in memory.</p>
<p>For both the dynamic and static builds, the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> structure is used for holding five variables that must always be available to the physics schemes. These variables are listed in a metadata table in <code class="docutils literal notranslate"><span class="pre">ccpp/framework/src/ccpp_types.F90</span></code> (<a class="reference internal" href="#mandatoryvariables"><span class="std std-ref">Listing 6.3</span></a>).</p>
<ul class="simple">
<li><p>Error flag for handling in CCPP (<code class="docutils literal notranslate"><span class="pre">errmsg</span></code>).</p></li>
<li><p>Error message associated with the error flag (<code class="docutils literal notranslate"><span class="pre">errflg</span></code>).</p></li>
<li><p>Loop counter for subcycling loops (<code class="docutils literal notranslate"><span class="pre">loop_cnt</span></code>).</p></li>
<li><p>Number of block for explicit data blocking in CCPP (<code class="docutils literal notranslate"><span class="pre">blk_no</span></code>).</p></li>
<li><p>Number of thread for threading in CCPP (<code class="docutils literal notranslate"><span class="pre">thrd_no</span></code>).</p></li>
</ul>
<div class="highlight-fortran notranslate" id="mandatoryvariables"><div class="highlight"><pre><span></span><span class="c">!! | local_name                        | standard_name             | long_name                                             | units   | rank | type      |   kind   | intent | optional |</span>
<span class="c">!! |-----------------------------------|-------------------------- |-------------------------------------------------------|---------|------|-----------|----------|--------|----------|</span>
<span class="c">!! | cdata%errflg                      | ccpp_error_flag           | error flag for error handling in CCPP                 | flag    |    0 | integer   |          | none   | F        |</span>
<span class="c">!! | cdata%errmsg                      | ccpp_error_message        | error message for error handling in CCPP              | none    |    0 | character | len=512  | none   | F        |</span>
<span class="c">!! | cdata%loop_cnt                    | ccpp_loop_counter         | loop counter for subcycling loops in CCPP             | index   |    0 | integer   |          | none   | F        |</span>
<span class="c">!! | cdata%blk_no                      | ccpp_block_number         | number of block for explicit data blocking in CCPP    | index   |    0 | integer   |          | none   | F        |</span>
<span class="c">!! | cdata%thrd_no                     | ccpp_thread_number        | number of thread for threading in CCPP                | index   |    0 | integer   |          | none   | F        |</span>
<span class="c">!!</span>
</pre></div>
</div>
<p><em>Listing 6.3: Mandatory variables provided by the CCPP-Framework from</em> <code class="docutils literal notranslate"><span class="pre">ccpp/framework/src/ccpp_types.F90</span></code> <em>.
These variables must not be defined by the host model.</em></p>
<p>Two of the variables are mandatory and must be passed to every physics scheme: <code class="docutils literal notranslate"><span class="pre">errmsg</span></code> and <code class="docutils literal notranslate"><span class="pre">errflg</span></code>. The variables <code class="docutils literal notranslate"><span class="pre">loop_cnt</span></code>, <code class="docutils literal notranslate"><span class="pre">blk_no</span></code>, and <code class="docutils literal notranslate"><span class="pre">thrd_no</span></code> can be passed to the schemes if required, but are not mandatory.  For the static build of the CCPP, the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> structure is only used to hold these five variables, since the host model variables are directly passed to the physics without the need for an intermediate data structure.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">cdata</span></code> is not restricted to being a scalar but can be a multidimensional array, depending on the needs of the host model. For example, a model that uses a one-dimensional array of blocks for better cache-reuse may require <code class="docutils literal notranslate"><span class="pre">cdata</span></code> to be a one-dimensional array of the same size. Another example of a multi-dimensional array of <code class="docutils literal notranslate"><span class="pre">cdata</span></code> is in the SCM, which uses a one-dimensional cdata array for N independent columns.</p>
<p>Due to a restriction in the Fortran language, there are no standard pointers that are generic pointers, such as the C language allows. The CCPP system therefore has an underlying set of pointers in the C language that are used to point to the original data within the host application cap. The user does not see this C data structure, but deals only with the public face of the Fortran <code class="docutils literal notranslate"><span class="pre">cdata</span></code> DDT. The type <code class="docutils literal notranslate"><span class="pre">ccpp_t</span></code> is defined in <code class="docutils literal notranslate"><span class="pre">ccpp/framework/src/ccpp_types.F90</span></code>.</p>
</div>
<div class="section" id="adding-and-retrieving-information-from-cdata-dynamic-build-option">
<h3>6.4.2. Adding and Retrieving Information from cdata (dynamic build option)<a class="headerlink" href="#adding-and-retrieving-information-from-cdata-dynamic-build-option" title="Permalink to this headline">¶</a></h3>
<p>Subroutines <code class="docutils literal notranslate"><span class="pre">ccpp_field_add</span></code> and <code class="docutils literal notranslate"><span class="pre">ccpp_field_get</span></code> are part of the CCPP-Framework and are used (in the dynamic build only) to load and retrieve information to and from <code class="docutils literal notranslate"><span class="pre">cdata</span></code>. The calls to <code class="docutils literal notranslate"><span class="pre">ccpp_field_add</span></code> are auto-generated by the script <code class="docutils literal notranslate"><span class="pre">ccpp_prebuild.py</span></code> and inserted onto the host model code via include files (i.e. <code class="docutils literal notranslate"><span class="pre">FV3/CCPP_layer/ccpp_fields_slow_physics.inc</span></code>) before it is compiled.</p>
<p>A typical call to <code class="docutils literal notranslate"><span class="pre">ccpp_field_add</span></code> is below, where the first argument is the instance of <code class="docutils literal notranslate"><span class="pre">cdata</span></code> to which the information should be added, the second argument is the <code class="docutils literal notranslate"><span class="pre">standard_name</span></code> of the variable, the third argument is the corresponding host model variable, the fourth argument is an error flag, the fifth argument is the units of the variable, and the last (optional) argument is the position within <code class="docutils literal notranslate"><span class="pre">cdata</span></code> in which the variable is expected to be stored.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">call </span><span class="n">ccpp_field_add</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="s1">&#39;y_wind_updated_by_physics&#39;</span><span class="p">,</span> <span class="n">GFS_Data</span><span class="p">(</span><span class="n">cdata</span><span class="p">%</span><span class="n">blk_no</span><span class="p">)%</span><span class="n">Stateout</span><span class="p">%</span><span class="n">gv0</span><span class="p">,</span> <span class="n">ierr</span><span class="o">=</span><span class="n">ierr</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;m s-1&#39;</span><span class="p">,</span> <span class="nb">index</span><span class="o">=</span><span class="mi">886</span><span class="p">)</span>
</pre></div>
</div>
<p>For DDTs, the interface to <code class="docutils literal notranslate"><span class="pre">CCPP_field_add</span></code> is slightly different:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">call </span><span class="n">ccpp_field_add</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="s1">&#39;GFS_cldprop_type_instance&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nb">c_loc</span><span class="p">(</span><span class="n">GFS_Data</span><span class="p">(</span><span class="n">cdata</span><span class="p">%</span><span class="n">blk_no</span><span class="p">)%</span><span class="n">Cldprop</span><span class="p">),</span> <span class="n">ierr</span><span class="o">=</span><span class="n">ierr</span><span class="p">,</span> <span class="nb">index</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>where the first argument and second arguments bear the same meaning as in the first example, the third argument is the units (can be left empty or set to “DDT”), the fourth argument is the C pointer to the variable in memory, the fifth argument is an error flag, and the last (optional) argument is the position within <code class="docutils literal notranslate"><span class="pre">cdata</span></code> as in the first example.</p>
<p>Each new variable added to <code class="docutils literal notranslate"><span class="pre">cdata</span></code> is always placed at the next free position, and a check is performed to confirm that this position corresponds to the expected one, which in this example is 886.  A mismatch will occur if a developer manually adds a call to <code class="docutils literal notranslate"><span class="pre">ccpp_field_add</span></code>, in which case a costly binary search is applied every time a variable is retrieved from memory. Adding calls manually is not recommended as all calls to <code class="docutils literal notranslate"><span class="pre">ccpp_fields_add</span></code> should be auto-generated.</p>
<p>The individual physics <em>caps</em> used in the dynamic build, which are auto-generated using the script <code class="docutils literal notranslate"><span class="pre">ccpp_prebuild.py</span></code>, contain calls to <code class="docutils literal notranslate"><span class="pre">ccpp_field_get</span></code> to pull data from the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> DDT as a Fortran pointer to a variable that will be passed to the individual physics scheme.</p>
</div>
<div class="section" id="initializing-and-finalizing-the-ccpp">
<h3>6.4.3. Initializing and Finalizing the CCPP<a class="headerlink" href="#initializing-and-finalizing-the-ccpp" title="Permalink to this headline">¶</a></h3>
<p>At the beginning of each run, the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> structure needs to be set up. Similarly, at the end of each run, it needs to be terminated. This is done with subroutines <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code> and <code class="docutils literal notranslate"><span class="pre">ccpp_finalize</span></code>. These subroutines should not be confused with <code class="docutils literal notranslate"><span class="pre">ccpp_physics_init</span></code> and <code class="docutils literal notranslate"><span class="pre">ccpp_physics_finalize</span></code>, which were described in <a class="reference internal" href="AutoGenPhysCaps.html#autogenphyscaps"><span class="std std-numref">Chapter 5</span></a>.</p>
<p>Note that optional arguments are denoted with square brackets.</p>
<div class="section" id="suite-initialization-subroutine">
<span id="suiteinitsubroutine"></span><h4>6.4.3.1. Suite Initialization Subroutine<a class="headerlink" href="#suite-initialization-subroutine" title="Permalink to this headline">¶</a></h4>
<p>The suite initialization subroutine, <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code>, takes three mandatory and two optional arguments. The mandatory arguments are the name of the suite (of type character), the name of the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> variable that must be allocated at this point, and an integer used for the error status. Note that the suite initialization routine <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code> parses the SDF corresponding to the given suite name and initializes the state of the suite and its schemes. This process must be repeated for every element of a multi-dimensional <code class="docutils literal notranslate"><span class="pre">cdata</span></code>. For performance reasons, it is possible to avoid repeated reads of the SDF and to have a single state of the suite shared between the elements of <code class="docutils literal notranslate"><span class="pre">cdata</span></code>. To do so, specify an optional argument variable called <code class="docutils literal notranslate"><span class="pre">cdata_target</span> <span class="pre">=</span> <span class="pre">X</span></code> in the call to <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code>, where <code class="docutils literal notranslate"><span class="pre">X</span></code> refers to the instance of <code class="docutils literal notranslate"><span class="pre">cdata</span></code> that has already been initialized.</p>
<p>For a given suite name <code class="docutils literal notranslate"><span class="pre">XYZ</span></code>, the name of the suite definition file is inferred as <code class="docutils literal notranslate"><span class="pre">suite_XYZ.xml</span></code>, and the file is expected to be present in the current run directory. It is possible to specify the optional argument <code class="docutils literal notranslate"><span class="pre">is_filename=.true.</span></code> to <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code>, which will treat the suite name as an actual file name (with or without the path to it).</p>
<p>Typical calls to <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code> are below, where <code class="docutils literal notranslate"><span class="pre">ccpp_suite</span></code> is the name of the suite, and <code class="docutils literal notranslate"><span class="pre">ccpp_sdf_filepath</span></code> the actual SDF filename, with or without a path to it.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">call </span><span class="n">ccpp_init</span><span class="p">(</span><span class="nb">trim</span><span class="p">(</span><span class="n">ccpp_suite</span><span class="p">),</span> <span class="n">cdata</span><span class="p">,</span> <span class="n">ierr</span><span class="p">)</span>
<span class="k">call </span><span class="n">ccpp_init</span><span class="p">(</span><span class="nb">trim</span><span class="p">(</span><span class="n">ccpp_suite</span><span class="p">),</span> <span class="n">cdata2</span><span class="p">,</span> <span class="n">ierr</span><span class="p">,</span> <span class="p">[</span><span class="n">cdata_target</span><span class="o">=</span><span class="n">cdata</span><span class="p">])</span>
<span class="k">call </span><span class="n">ccpp_init</span><span class="p">(</span><span class="nb">trim</span><span class="p">(</span><span class="n">ccpp_sdf_filepath</span><span class="p">),</span> <span class="n">cdata</span><span class="p">,</span> <span class="n">ierr</span><span class="p">,</span> <span class="p">[</span><span class="n">is_filename</span><span class="o">=</span><span class="p">.</span><span class="n">true</span><span class="p">.])</span>
</pre></div>
</div>
</div>
<div class="section" id="suite-finalization-subroutine">
<h4>6.4.3.2. Suite Finalization Subroutine<a class="headerlink" href="#suite-finalization-subroutine" title="Permalink to this headline">¶</a></h4>
<p>The suite finalization subroutine, <code class="docutils literal notranslate"><span class="pre">ccpp_finalize</span></code>, takes two arguments, the name of the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> variable that must be de-allocated at this point, and an integer used for the error status. A typical call to <code class="docutils literal notranslate"><span class="pre">ccpp_finalize</span></code> is below:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">call </span><span class="n">ccpp_finalize</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="n">ierr</span><span class="p">)</span>
</pre></div>
</div>
<p>If a specific data instance was used in a call to <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code>, as in the above example in <a class="reference internal" href="#suiteinitsubroutine"><span class="std std-numref">Section 6.4.3.1</span></a>, then this data instance must be finalized last:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">call </span><span class="n">ccpp_finalize</span><span class="p">(</span><span class="n">cdata2</span><span class="p">,</span> <span class="n">ierr</span><span class="p">)</span>
<span class="k">call </span><span class="n">ccpp_finalize</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="n">ierr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="running-the-physics">
<h3>6.4.4. Running the physics<a class="headerlink" href="#running-the-physics" title="Permalink to this headline">¶</a></h3>
<p>The physics is invoked by calling subroutine <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run</span></code>. This subroutine is part of the CCPP API and is included with the CCPP-Framework (for the dynamic build) or auto-generated (for the static build). This subroutine is capable of executing the physics with varying granularity, that is, a single scheme (dynamic build only), a single group, or an entire suite can be run with a single subroutine call. Typical calls to <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run</span></code> are below, where <code class="docutils literal notranslate"><span class="pre">scheme_name</span></code> and <code class="docutils literal notranslate"><span class="pre">group_name</span></code> are optional and mutually exclusive (dynamic build), and where <code class="docutils literal notranslate"><span class="pre">suite_name</span></code> is mandatory and <code class="docutils literal notranslate"><span class="pre">group_name</span></code> is optional (static build).</p>
<p>Dynamic build:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">call </span><span class="n">ccpp_physics_run</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="p">[</span><span class="n">group_name</span><span class="p">],</span> <span class="p">[</span><span class="n">scheme_name</span><span class="p">],</span> <span class="n">ierr</span><span class="o">=</span><span class="n">ierr</span><span class="p">)</span>
</pre></div>
</div>
<p>Static build:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">call </span><span class="n">ccpp_physics_run</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="n">suite_name</span><span class="p">,</span> <span class="p">[</span><span class="n">group_name</span><span class="p">],</span> <span class="n">ierr</span><span class="o">=</span><span class="n">ierr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="initializing-and-finalizing-the-physics">
<h3>6.4.5. Initializing and Finalizing the Physics<a class="headerlink" href="#initializing-and-finalizing-the-physics" title="Permalink to this headline">¶</a></h3>
<p>Many (but not all) physical parameterizations need to be initialized, which includes functions such as reading lookup tables, reading input datasets, computing derived quantities, broadcasting information to all MPI ranks, etc. Initialization procedures are typically done for the entire domain, that is, they are not subdivided by blocks. Similarly, many (but not all) parameterizations need to be finalized, which includes functions such as deallocating variables, resetting flags from <em>initialized</em> to <em>non-initiaIized</em>, etc. Initialization and finalization functions are each performed once per run, before the first call to the physics and after the last call to the physics, respectively.</p>
<p>The initialization and finalization can be invoked for a single parameterization (only in dynamic build), for a single group, or for the entire suite. In all cases, subroutines <code class="docutils literal notranslate"><span class="pre">ccpp_physics_init</span></code> and <code class="docutils literal notranslate"><span class="pre">ccpp_physics_finalize</span></code> are used and the arguments passed to those subroutines determine the type of initialization.</p>
<p>These subroutines should not be confused with <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code> and <code class="docutils literal notranslate"><span class="pre">ccpp_finalize</span></code>, which were explained previously.</p>
<div class="section" id="subroutine-ccpp-physics-init">
<h4>6.4.5.1. Subroutine <code class="docutils literal notranslate"><span class="pre">ccpp_physics_init</span></code><a class="headerlink" href="#subroutine-ccpp-physics-init" title="Permalink to this headline">¶</a></h4>
<p>This subroutine is part of the CCPP API and is included with the CCPP-Framework (for the dynamic build) or auto-generated (for the static build). It cannot contain thread-dependent information but can have block-dependent information. Typical calls to <code class="docutils literal notranslate"><span class="pre">ccpp_physics_init</span></code> are below.</p>
<p>Dynamic build:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">call </span><span class="n">ccpp_physics_init</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="p">[</span><span class="n">group_name</span><span class="p">],</span> <span class="p">[</span><span class="n">scheme_name</span><span class="p">],</span> <span class="n">ierr</span><span class="o">=</span><span class="n">ierr</span><span class="p">)</span>
</pre></div>
</div>
<p>Static build:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">call </span><span class="n">ccpp_physics_init</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="n">suite_name</span><span class="p">,</span> <span class="p">[</span><span class="n">group_name</span><span class="p">],</span> <span class="n">ierr</span><span class="o">=</span><span class="n">ierr</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="subroutine-ccpp-physics-finalize">
<h4>6.4.5.2. Subroutine <code class="docutils literal notranslate"><span class="pre">ccpp_physics_finalize</span></code><a class="headerlink" href="#subroutine-ccpp-physics-finalize" title="Permalink to this headline">¶</a></h4>
<p>This subroutine is part of the CCPP API and is included with the CCPP-Framework (for the dynamic build) or auto-generated (for the static build). Typical calls to <code class="docutils literal notranslate"><span class="pre">ccpp_physics_finalize</span></code> are below.</p>
<p>Dynamic build:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">call </span><span class="n">ccpp_physics_finalize</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="p">[</span><span class="n">group_name</span><span class="p">],</span> <span class="p">[</span><span class="n">scheme_name</span><span class="p">],</span> <span class="n">ierr</span><span class="o">=</span><span class="n">ierr</span><span class="p">)</span>
</pre></div>
</div>
<p>Static build:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">call </span><span class="n">ccpp_physics_finalize</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="n">suite_name</span><span class="p">,</span> <span class="p">[</span><span class="n">group_name</span><span class="p">],</span> <span class="n">ierr</span><span class="o">=</span><span class="n">ierr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="host-caps">
<h2>6.5. Host Caps<a class="headerlink" href="#host-caps" title="Permalink to this headline">¶</a></h2>
<p>The purpose of the host model <em>cap</em> is to abstract away the communication between the host model and the CCPP-Physics schemes. While CCPP calls can be placed directly inside the host model code (as is done for the relatively simple SCM), it is recommended to separate the <em>cap</em> in its own module for clarity and simplicity (as is done for the UFS Atmosphere). While the details of implementation will be specific to each host model, the host model <em>cap</em> is responsible for the following general functions:</p>
<ul>
<li><p>Allocating memory for variables needed by physics</p>
<ul class="simple">
<li><p>All variables needed to communicate between the host model and the physics, and all variables needed to communicate among physics schemes, need to be allocated by the host model. The latter, for example for interstitial variables used exclusively for communication between the physics schemes, are typically allocated in the <em>cap</em>.</p></li>
</ul>
</li>
<li><p>Allocating the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> structure(s)</p>
<ul class="simple">
<li><p>For the dynamic build, the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> structure handles the data exchange between the host model and the physics schemes, while for the static build, <code class="docutils literal notranslate"><span class="pre">cdata</span></code> is utilized in a reduced capacity.</p></li>
</ul>
</li>
<li><p>Calling the suite initialization subroutine</p>
<ul class="simple">
<li><p>The suite must be initialized using <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code>.</p></li>
</ul>
</li>
<li><p>Populating the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> structure(s)</p>
<ul>
<li><p>For the dynamic build, each variable required by the physics schemes must be added to the <code class="docutils literal notranslate"><span class="pre">cdata</span></code>
structure (or to each element of a multi-dimensional <code class="docutils literal notranslate"><span class="pre">cdata</span></code>) on the host model side using subroutine
<code class="docutils literal notranslate"><span class="pre">ccpp_field_add</span></code>. This is an automated task accomplished by inserting a preprocessor directive</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="cp">#include ccpp_modules.inc</span>
</pre></div>
</div>
<p>at the top of the cap (before implicit none) to load the required modules and a second preprocessor directive</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="cp">#include ccpp_fields.inc</span>
</pre></div>
</div>
<p>after the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> variable and the variables required by the physics schemes are allocated and after the
call to <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code> for this <code class="docutils literal notranslate"><span class="pre">cdata</span></code> variable. For the static build, this step can be skipped because
the autogenerated <em>caps</em> for the physics (groups and suite <em>caps</em>) are automatically given memory access to the
host model variables and they can be used directly, without the need for a data structure containing pointers
to the actual variables (which is what <code class="docutils literal notranslate"><span class="pre">cdata</span></code> is).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The CCPP-Framework supports splitting physics schemes into different sets that are used in different parts of the host model. An example is the separation between slow and fast physics processes for the GFDL microphysics implemented in the UFS Atmosphere: while the slow physics are called as part of the usual model physics, the fast physics are integrated in the dynamical core. The separation of physics into different sets is determined in the CCPP <em>prebuild</em> configuration for each host model (see <a class="reference internal" href="AutoGenPhysCaps.html#dynamicbuildcaps"><span class="std std-numref">Chapter 5.1</span></a>, and <a class="reference internal" href="CCPPPreBuild.html#ccpp-prebuild"><span class="std std-numref">Figure 8.1</span></a>), which allows to create multiple include files (e.g. <code class="docutils literal notranslate"><span class="pre">ccpp_fields_slow_physics.inc</span></code> and <code class="docutils literal notranslate"><span class="pre">ccpp_fields_fast_physics.inc</span></code> that can be used by different <code class="docutils literal notranslate"><span class="pre">cdata</span></code> structures in different parts of the model). This is a highly advanced feature and developers seeking to take further advantage of it should consult with GMTB first.</p>
</div>
</li>
</ul>
</li>
<li><p>Providing interfaces to call the CCPP</p>
<ul class="simple">
<li><p>The <em>cap</em> must provide functions or subroutines that can be called at the appropriate places in the host model time integration loop and that internally call <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code>, <code class="docutils literal notranslate"><span class="pre">ccpp_physics_init</span></code>, <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run</span></code>, <code class="docutils literal notranslate"><span class="pre">ccpp_physics_finalize</span></code> and <code class="docutils literal notranslate"><span class="pre">ccpp_finalize</span></code>, and handle any errors returned See <a class="reference internal" href="#example-ccpp-host-cap"><span class="std std-ref">Listing 6.4</span></a>.</p></li>
</ul>
</li>
</ul>
<div class="highlight-fortran notranslate" id="example-ccpp-host-cap"><div class="highlight"><pre><span></span><span class="k">module </span><span class="n">example_ccpp_host_cap</span>

 <span class="k">use </span><span class="n">ccpp_api</span><span class="p">,</span>           <span class="n">only</span><span class="p">:</span> <span class="n">ccpp_t</span><span class="p">,</span> <span class="n">ccpp_init</span><span class="p">,</span> <span class="n">ccpp_finalize</span>
 <span class="k">use </span><span class="n">ccpp_static_api</span><span class="p">,</span>    <span class="n">only</span><span class="p">:</span> <span class="n">ccpp_physics_init</span><span class="p">,</span> <span class="n">ccpp_physics_run</span><span class="p">,</span>     <span class="p">&amp;</span>
                               <span class="n">ccpp_physics_finalize</span>

  <span class="k">implicit none</span>
  <span class="c">! CCPP data structure</span>
  <span class="k">type</span><span class="p">(</span><span class="n">ccpp_t</span><span class="p">),</span> <span class="k">save</span><span class="p">,</span> <span class="k">target</span> <span class="kd">::</span> <span class="n">cdata</span>
  <span class="k">public</span> <span class="kd">::</span> <span class="n">physics_init</span><span class="p">,</span> <span class="n">physics_run</span><span class="p">,</span> <span class="n">physics_finalize</span>
<span class="k">contains</span>

<span class="k"> subroutine </span><span class="n">physics_init</span><span class="p">(</span><span class="n">ccpp_suite_name</span><span class="p">)</span>
   <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">ccpp_suite_name</span>
   <span class="kt">integer</span> <span class="kd">::</span> <span class="n">ierr</span>
   <span class="n">ierr</span> <span class="o">=</span> <span class="mi">0</span>

   <span class="c">! Initialize the CCPP framework, parse SDF</span>
   <span class="k">call </span><span class="n">ccpp_init</span><span class="p">(</span><span class="nb">trim</span><span class="p">(</span><span class="n">ccpp_suite_name</span><span class="p">),</span> <span class="n">cdata</span><span class="p">,</span> <span class="n">ierr</span><span class="o">=</span><span class="n">ierr</span><span class="p">)</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">ierr</span><span class="o">/=</span><span class="mi">0</span><span class="p">)</span> <span class="k">then</span>
<span class="k">     write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s1">&#39;(a)&#39;</span><span class="p">)</span> <span class="s2">&quot;An error occurred in ccpp_init&quot;</span>
     <span class="k">stop</span>
<span class="k">   end if</span>

   <span class="c">! Initialize CCPP physics (run all _init routines)</span>
   <span class="k">call </span><span class="n">ccpp_physics_init</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="n">suite_name</span><span class="o">=</span><span class="nb">trim</span><span class="p">(</span><span class="n">ccpp_suite_name</span><span class="p">),</span>      <span class="p">&amp;</span>
                          <span class="n">ierr</span><span class="o">=</span><span class="n">ierr</span><span class="p">)</span>
   <span class="c">! error handling as above</span>

 <span class="k">end subroutine </span><span class="n">physics_init</span>

 <span class="k">subroutine </span><span class="n">physics_run</span><span class="p">(</span><span class="n">ccpp_suite_name</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>
   <span class="c">! Optional argument group can be used to run a group of schemes      &amp;</span>
   <span class="c">! defined in the SDF. Otherwise, run entire suite.</span>
   <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span>           <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">ccpp_suite_name</span>
   <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span> <span class="k">optional</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">group</span>

   <span class="kt">integer</span> <span class="kd">::</span> <span class="n">ierr</span>
   <span class="n">ierr</span> <span class="o">=</span> <span class="mi">0</span>

   <span class="k">if</span> <span class="p">(</span><span class="nb">present</span><span class="p">(</span><span class="n">group</span><span class="p">))</span> <span class="k">then</span>
<span class="k">      call </span><span class="n">ccpp_physics_run</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="n">suite_name</span><span class="o">=</span><span class="nb">trim</span><span class="p">(</span><span class="n">ccpp_suite_name</span><span class="p">),</span>    <span class="p">&amp;</span>
                            <span class="n">group_name</span><span class="o">=</span><span class="n">group</span><span class="p">,</span> <span class="n">ierr</span><span class="o">=</span><span class="n">ierr</span><span class="p">)</span>
   <span class="k">else</span>
<span class="k">      call </span><span class="n">ccpp_physics_run</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="n">suite_name</span><span class="o">=</span><span class="nb">trim</span><span class="p">(</span><span class="n">ccpp_suite_name</span><span class="p">),</span>    <span class="p">&amp;</span>
                            <span class="n">ierr</span><span class="o">=</span><span class="n">ierr</span><span class="p">)</span>
   <span class="k">end if</span>
   <span class="c">! error handling as above</span>

 <span class="k">end subroutine </span><span class="n">physics_run</span>

 <span class="k">subroutine </span><span class="n">physics_finalize</span><span class="p">(</span><span class="n">ccpp_suite_name</span><span class="p">)</span>
   <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">ccpp_suite_name</span>
   <span class="kt">integer</span> <span class="kd">::</span> <span class="n">ierr</span>
   <span class="n">ierr</span> <span class="o">=</span> <span class="mi">0</span>

   <span class="c">! Finalize CCPP physics (run all _finalize routines)</span>
   <span class="k">call </span><span class="n">ccpp_physics_finalize</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="n">suite_name</span><span class="o">=</span><span class="nb">trim</span><span class="p">(</span><span class="n">ccpp_suite_name</span><span class="p">),</span>  <span class="p">&amp;</span>
                              <span class="n">ierr</span><span class="o">=</span><span class="n">ierr</span><span class="p">)</span>
   <span class="c">! error handling as above</span>
   <span class="k">call </span><span class="n">ccpp_finalize</span><span class="p">(</span><span class="n">cdata</span><span class="p">,</span> <span class="n">ierr</span><span class="o">=</span><span class="n">ierr</span><span class="p">)</span>
   <span class="c">! error handling as above</span>

 <span class="k">end subroutine </span><span class="n">physics_finalize</span>

<span class="k">end module </span><span class="n">example_ccpp_host_cap</span>
</pre></div>
</div>
<p><em>Listing 6.4: Fortran template for a CCPP host model cap from</em> <code class="docutils literal notranslate"><span class="pre">ccpp/framework/doc/DevelopersGuide/host_cap_template.F90</span></code>.</p>
<p>The following sections describe two implementations of host model caps to serve as examples. For each of the functions listed above, a description for how it is implemented in each host model is included.</p>
<div class="section" id="scm-host-cap">
<h3>6.5.1. SCM Host Cap<a class="headerlink" href="#scm-host-cap" title="Permalink to this headline">¶</a></h3>
<p>The only build type available for the SCM is the dynamic build. The cap functions are mainly implemented in:</p>
<p><code class="docutils literal notranslate"><span class="pre">gmtb-scm/scm/src/gmtb_scm.F90</span></code></p>
<p>With smaller parts in:</p>
<p><code class="docutils literal notranslate"><span class="pre">gmtb-scm/scm/src/gmtb_scm_type_defs.f90</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">gmtb-scm/scm/src/gmtb_scm_setup.f90</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">gmtb-scm/scm/src/gmtb_scm_time_integration.f90</span></code></p>
<p>The host model <em>cap</em> is responsible for:</p>
<ul>
<li><p>Allocating memory for variables needed by physics</p>
<p>All variables and constants required by the physics have metadata provided on the host-side, <code class="docutils literal notranslate"><span class="pre">arg_table_physics_type</span></code> and <code class="docutils literal notranslate"><span class="pre">arg_table_gmtb_scm_physical_constants</span></code>, which are implemented in <code class="docutils literal notranslate"><span class="pre">gmtb_scm_type_defs.f90</span></code> and <code class="docutils literal notranslate"><span class="pre">gmtb_scm_physical_constants.f90</span></code>. To mimic the UFS Atmosphere and to hopefully reduce code maintenance, currently, the SCM uses GFS DDTs as sub-types within the physics DDT.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">gmtb_scm_type_defs.f90</span></code>, the physics DDT has a create type-bound procedure (see subroutine <code class="docutils literal notranslate"><span class="pre">physics_create</span></code> and <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">physics_type</span></code>), which allocates GFS sub-DDTs and other physics variables and initializes them with zeros. <code class="docutils literal notranslate"><span class="pre">physics%create</span></code> is called from <code class="docutils literal notranslate"><span class="pre">gmtb_scm.F90</span></code> after the initial SCM state has been set up.</p>
</li>
<li><p>Allocating the cdata structure</p>
<p>The SCM uses a one-dimensional <code class="docutils literal notranslate"><span class="pre">cdata</span></code> array for N independent columns, i.e. in <code class="docutils literal notranslate"><span class="pre">gmtb_scm.F90</span></code>:</p>
<p><code class="docutils literal notranslate"><span class="pre">allocate(cdata(scm_state%n_cols))</span></code></p>
</li>
<li><p>Calling the suite initialization subroutine</p>
<p>Within <code class="docutils literal notranslate"><span class="pre">scm_state%n_cols</span></code> loop in <code class="docutils literal notranslate"><span class="pre">gmtb_scm.F90</span></code> after initial SCM state setup and before first timestep, the suite initialization subroutine <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code> is called for each column with own instance of <code class="docutils literal notranslate"><span class="pre">cdata</span></code>, and takes three arguments, the name of the runtime SDF, the name of the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> variable that must be allocated at this point, and <code class="docutils literal notranslate"><span class="pre">ierr</span></code>.</p>
</li>
<li><p>Populating the cdata structure</p>
<p>Within the same <code class="docutils literal notranslate"><span class="pre">scm_state%n_cols</span></code> loop, but after the <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code> call, the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> structure is filled in with real initialized values:</p>
</li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physics%Init_parm</span></code> (GFS DDT for setting up suite) are filled in from <code class="docutils literal notranslate"><span class="pre">scm_state%</span></code></p></li>
<li><p>call <code class="docutils literal notranslate"><span class="pre">GFS_suite_setup()</span></code>: similar to <code class="docutils literal notranslate"><span class="pre">GFS_initialize()</span></code> in the UFS Atmosphere, is called and includes:</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">%init/%create</span></code> calls for GFS DDTs</p></li>
<li><p>initialization for other variables in physics DDT</p></li>
<li><p>init calls for legacy non-ccpp schemes</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>call <code class="docutils literal notranslate"><span class="pre">physics%associate()</span></code>: to associate pointers in physics DDT with targets in <code class="docutils literal notranslate"><span class="pre">scm_state</span></code>, which contains variables that are modified by the SCM “dycore” (i.e. forcing).</p></li>
<li><p>Actual <code class="docutils literal notranslate"><span class="pre">cdata</span></code> fill in through <code class="docutils literal notranslate"><span class="pre">ccpp_field_add</span></code> calls:</p></li>
</ul>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">“ccpp_fields.inc”</span></code></p>
<p>This include file is auto-generated from <code class="docutils literal notranslate"><span class="pre">ccpp/scripts/ccpp_prebuild.py</span></code>, which parses tables in <code class="docutils literal notranslate"><span class="pre">gmtb_scm_type_defs.f90</span></code>.</p>
</div></blockquote>
</div></blockquote>
<ul class="simple">
<li><p>Providing interfaces to call the CCPP</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>Calling <code class="docutils literal notranslate"><span class="pre">ccpp_physics_init()</span></code></p></li>
</ul>
<blockquote>
<div><p>Within the same <code class="docutils literal notranslate"><span class="pre">scm_state%n_cols</span></code> loop but after <code class="docutils literal notranslate"><span class="pre">cdata</span></code> is filled, the physics initialization routines (<code class="docutils literal notranslate"><span class="pre">*_init()</span></code>) associated with the physics suite, group, and/or schemes are called at each column.</p>
</div></blockquote>
<ul class="simple">
<li><p>Calling <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run()</span></code></p></li>
</ul>
<blockquote>
<div><p>At the first timestep, if the forward scheme is selected (i.e. <code class="docutils literal notranslate"><span class="pre">scm_state%time_scheme</span> <span class="pre">==</span> <span class="pre">1</span></code>), call <code class="docutils literal notranslate"><span class="pre">do_time_step()</span></code> to apply forcing and <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run()</span></code> calls at each column; if the leapfrog scheme is selected (i.e. <code class="docutils literal notranslate"><span class="pre">scm_state%time_scheme</span> <span class="pre">==</span> <span class="pre">2</span></code>), call <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run()</span></code> directly at each column.</p>
<p>At a later time integration, call <code class="docutils literal notranslate"><span class="pre">do_time_step()</span></code> to apply forcing and <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run()</span></code> calls at each column. Since there is no need to execute anything between physics groups in the SCM, the <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run</span></code> call is only given cdata and an error flag as arguments.</p>
</div></blockquote>
<ul class="simple">
<li><p>Calling <code class="docutils literal notranslate"><span class="pre">ccpp_physics_finalize()</span></code> and <code class="docutils literal notranslate"><span class="pre">ccpp_finalize()</span></code></p></li>
</ul>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">ccpp_physics_finalize()</span></code> and <code class="docutils literal notranslate"><span class="pre">ccpp_finalize()</span></code> are called after the time loop at each column.</p>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="ufs-atmosphere-host-cap">
<h3>6.5.2. UFS Atmosphere Host Cap<a class="headerlink" href="#ufs-atmosphere-host-cap" title="Permalink to this headline">¶</a></h3>
<p>For the UFS Atmosphere, there are slightly different versions of the host cap implementation depending on the desired build type (dynamic or static). As discussed in <a class="reference internal" href="CCPPPreBuild.html#ccppprebuild"><span class="std std-numref">Chapter 8</span></a>, these modes are controlled via appropriate strings included in the MAKEOPTS build-time argument. Within the source code, the three modes are executed within appropriate pre-processor directive blocks:</p>
<p>For any build that uses CCPP (dynamic orstatic):</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef CCPP</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>For static (often nested within <code class="docutils literal notranslate"><span class="pre">#ifdef</span> <span class="pre">CCPP</span></code>):</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef STATIC</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>The following text describes how the host cap functions listed above are implemented for the dynamic build only. Where the other modes of operation differ in their implementation, it will be called out.</p>
<ul class="simple">
<li><p>Allocating memory for variables needed by physics</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>Within the <code class="docutils literal notranslate"><span class="pre">atmos_model_init</span></code> subroutine of <code class="docutils literal notranslate"><span class="pre">atmos_model.F90</span></code>, the following statement is executed</p></li>
</ul>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">allocate(IPD_Data)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">IPD_Data</span></code> is of <code class="docutils literal notranslate"><span class="pre">IPD_data_type</span></code>, which is defined in <code class="docutils literal notranslate"><span class="pre">IPD_typedefs.F90</span></code> as a synonym for <code class="docutils literal notranslate"><span class="pre">GFS_data_type</span></code> defined in <code class="docutils literal notranslate"><span class="pre">GFS_typedefs.F90</span></code>. This data type contains GFS-related DDTs (<code class="docutils literal notranslate"><span class="pre">GFS_statein_type</span></code>, <code class="docutils literal notranslate"><span class="pre">GFS_stateout_type</span></code>, <code class="docutils literal notranslate"><span class="pre">GFS_sfcprop_type</span></code>, etc.) as sub-types, which are defined in <code class="docutils literal notranslate"><span class="pre">GFS_typedefs.F90</span></code>.</p>
</div></blockquote>
</div></blockquote>
<ul class="simple">
<li><p>Allocating the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> structures</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>For the current implementation of the UFS Atmosphere, which uses a subset of fast physics processes tightly coupled to the dynamical core, three instances of <code class="docutils literal notranslate"><span class="pre">cdata</span></code> exist within the host model: <code class="docutils literal notranslate"><span class="pre">cdata_tile</span></code> to hold data for the fast physics, <code class="docutils literal notranslate"><span class="pre">cdata_domain</span></code> to hold data needed for all UFS Atmosphere blocks for the slow physics, and <code class="docutils literal notranslate"><span class="pre">cdata_block</span></code>, an array of <code class="docutils literal notranslate"><span class="pre">cdata</span></code> DDTs with dimensions of (<code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">of</span> <span class="pre">blocks</span></code>, <code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">of</span> <span class="pre">threads</span></code>) to contain data for individual block/thread combinations for the slow physics. All are defined as module-level variables in the <code class="docutils literal notranslate"><span class="pre">CCPP_data</span> <span class="pre">module</span></code> of <code class="docutils literal notranslate"><span class="pre">CCPP_data.F90</span></code>. The <code class="docutils literal notranslate"><span class="pre">cdata_block</span></code> array is allocated (since the number of blocks and threads is unknown at compile-time) as part of the <code class="docutils literal notranslate"><span class="pre">‘init’</span></code> step of the <code class="docutils literal notranslate"><span class="pre">CCPP_step</span> <span class="pre">subroutine</span></code> in <code class="docutils literal notranslate"><span class="pre">CCPP_driver.F90</span></code>. Note: Although the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> containers are not used to hold the pointers to the physics variables for the static mode, they are still used to hold other CCPP-related information for that mode.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>Calling the suite initialization subroutine</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>Corresponding to the three instances of <code class="docutils literal notranslate"><span class="pre">cdata</span></code> described above, the <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code> subroutine is called within three different contexts, all originating from the <code class="docutils literal notranslate"><span class="pre">atmos_model_init</span></code> subroutine of <code class="docutils literal notranslate"><span class="pre">atmos_model.F90</span></code>:</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>For <code class="docutils literal notranslate"><span class="pre">cdata_tile</span></code> (used for the fast physics), the <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code> call is made from the <code class="docutils literal notranslate"><span class="pre">atmosphere_init</span></code> subroutine of <code class="docutils literal notranslate"><span class="pre">atmosphere.F90</span></code>. Note: when fast physics is used, this is the <em>first</em> call to <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code>, so it reads in the SDF and initializes the suite in addition to setting up the fields for <code class="docutils literal notranslate"><span class="pre">cdata_tile</span></code>.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">cdata_domain</span></code> and <code class="docutils literal notranslate"><span class="pre">cdata_block</span></code> used in the rest of the physics, the ‘init’ step of the <code class="docutils literal notranslate"><span class="pre">CCPP_step</span></code> subroutine in <code class="docutils literal notranslate"><span class="pre">CCPP_driver.F90</span></code> is called. Within that subroutine, <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code> is called once to set up <code class="docutils literal notranslate"><span class="pre">cdata_domain</span></code> and within a loop for every block/thread combination to set up the components of the <code class="docutils literal notranslate"><span class="pre">cdata_block</span></code> array. Note: as mentioned in the CCPP API <a class="reference internal" href="#ccpp-api"><span class="std std-numref">Section 6.4</span></a>, when fast physics is used, the SDF has already been read and the suite is already setup, so this step is skipped and the suite information is simply copied from what was already initialized (<code class="docutils literal notranslate"><span class="pre">cdata_tile</span></code>) using the <code class="docutils literal notranslate"><span class="pre">cdata_target</span></code> optional argument.</p></li>
</ul>
</div></blockquote>
</div></blockquote>
<ul class="simple">
<li><p>Populating the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> structures</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>When the dynamic mode is used, the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> structures are filled with pointers to variables that are used by physics and whose memory is allocated by the host model. This is done using <code class="docutils literal notranslate"><span class="pre">ccpp_field_add</span></code> statements contained in the autogenerated include files. For the fast physics, this include file is named <code class="docutils literal notranslate"><span class="pre">ccpp_fields_fast_physics.inc</span></code> and is placed after the call to <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code> for <code class="docutils literal notranslate"><span class="pre">cdata_tile</span></code> in the <code class="docutils literal notranslate"><span class="pre">atmosphere_init</span></code> subroutine of <code class="docutils literal notranslate"><span class="pre">atmosphere.F90</span></code>. For populating <code class="docutils literal notranslate"><span class="pre">cdata_domain</span></code> and <code class="docutils literal notranslate"><span class="pre">cdata_block</span></code>, IPD data types are initialized in the <code class="docutils literal notranslate"><span class="pre">atmos_model_init</span></code> subroutine of <code class="docutils literal notranslate"><span class="pre">atmos_model.F90</span></code>. The <code class="docutils literal notranslate"><span class="pre">Init_parm</span></code> DDT is filled directly in this routine and <code class="docutils literal notranslate"><span class="pre">IPD_initialize</span></code> (pointing to <code class="docutils literal notranslate"><span class="pre">GFS_initialize</span></code> and for populating diagnostics and restart DDTs) is called in order to fill the GFS DDTs that are used in the physics. Once the IPD data types are filled, they are passed to the ‘init’ step of the <code class="docutils literal notranslate"><span class="pre">CCPP_step</span></code> subroutine in <code class="docutils literal notranslate"><span class="pre">CCPP_driver.F90</span></code> where <code class="docutils literal notranslate"><span class="pre">ccpp_field_add</span></code> statements are included in <code class="docutils literal notranslate"><span class="pre">ccpp_fields_slow_physics.inc</span></code> after the calls to <code class="docutils literal notranslate"><span class="pre">ccpp_init</span></code> for the <code class="docutils literal notranslate"><span class="pre">cdata_domain</span></code> and <code class="docutils literal notranslate"><span class="pre">cdata_block</span></code> containers.</p></li>
<li><p>Note: for the static mode, filling of the <code class="docutils literal notranslate"><span class="pre">cdata</span></code> containers with pointers to physics variables is not necessary. This is because the autogenerated <em>caps</em> for the physics groups (that contain calls to the member schemes) can fill in the argument variables without having to retrieve pointers to the actual data. This is possible because the metadata about host model variables (that are known at ccpp_prebuild time) contain all the information needed about the location (DDTs and local names) to pass into the autogenerated <em>caps</em> for their direct use.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>Providing interfaces to call the CCPP</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>Calling <code class="docutils literal notranslate"><span class="pre">ccpp_physics_init</span></code></p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>In order to call the initialization routines for the physics, <code class="docutils literal notranslate"><span class="pre">ccpp_physics_init</span></code> is called in the <code class="docutils literal notranslate"><span class="pre">atmosphere_init</span></code> subroutine of <code class="docutils literal notranslate"><span class="pre">atmosphere.F90</span></code> after the included <code class="docutils literal notranslate"><span class="pre">ccpp_field_add</span></code> calls for the fast physics. For the slow physics, the ‘physics_init’ step of the <code class="docutils literal notranslate"><span class="pre">CCPP_step</span></code> subroutine in <code class="docutils literal notranslate"><span class="pre">CCPP_driver.F90</span></code> is invoked immediately after the call to the ‘init’ step in the <code class="docutils literal notranslate"><span class="pre">atmos_model_init</span></code> subroutine of <code class="docutils literal notranslate"><span class="pre">atmos_model.F90</span></code>. Within the ‘physics_init’ step,  calls to <code class="docutils literal notranslate"><span class="pre">ccpp_physics_init</span></code> for all blocks are executed.</p></li>
<li><p>Note: for the static mode, <code class="docutils literal notranslate"><span class="pre">ccpp_physics_init</span></code> is autogenerated and contained within <code class="docutils literal notranslate"><span class="pre">ccpp_static_api.F90</span></code>. As mentioned in the <a class="reference internal" href="#ccpp-api"><span class="std std-numref">CCPP API Section 6.4</span></a> , it can be called to initialize groups as defined in the SDFs or the suite as a whole, depending on whether a group name is passed in as an optional argument.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>Calling <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run</span></code></p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>For actually running the physics within the FV3 time loop, <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run</span></code> is called from a couple of different places in the FV3 source code. For the fast physics, <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run</span></code> is called for the fast physics group from the <code class="docutils literal notranslate"><span class="pre">Lagrangian_to_Eulerian</span></code> subroutine of <code class="docutils literal notranslate"><span class="pre">fv_mapz.F90</span></code> within the dynamical core. For the rest of the physics, the subroutine <code class="docutils literal notranslate"><span class="pre">update_atmos_radiation_physics</span></code> in <code class="docutils literal notranslate"><span class="pre">atmos_model.F90</span></code> is called as part of the FV3 time loop. Within that subroutine, the various physics steps (defined as groups within a SDF) are called one after the other. The ‘time_vary’ step of the <code class="docutils literal notranslate"><span class="pre">CCPP_step</span></code> subroutine within <code class="docutils literal notranslate"><span class="pre">CCPP_driver.F90</span></code> is called. Since this step is called over the entire domain, the call to <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run</span></code> is done once using <code class="docutils literal notranslate"><span class="pre">cdata_domain</span></code> and the time_vary group.  The ‘radiation’, ‘physics’, and ‘stochastics’ steps of the <code class="docutils literal notranslate"><span class="pre">CCPP_step</span></code> subroutine are called next. For each of these steps within <code class="docutils literal notranslate"><span class="pre">CCPP_step</span></code>, there is a loop over the number of blocks for calling <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run</span></code> with the appropriate group and component of the <code class="docutils literal notranslate"><span class="pre">cdata_block</span></code> array for the current block and thread.</p></li>
<li><p>Note: The execution of calls to <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run</span></code> is different for the three build types. For the static mode, <code class="docutils literal notranslate"><span class="pre">ccpp_physics_run</span></code> is called from <code class="docutils literal notranslate"><span class="pre">ccpp_static_api.F90</span></code> and contains autogenerated caps for groups and the suite as a whole as defined in the SDFs.</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>calling <code class="docutils literal notranslate"><span class="pre">ccpp_physics_finalize</span></code> and <code class="docutils literal notranslate"><span class="pre">ccpp_finalize</span></code></p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>At the conclusion of the FV3 time loop, calls to finalize the physics are executed. For the fast physics, <code class="docutils literal notranslate"><span class="pre">ccpp_physics_finalize</span></code> is called from the <code class="docutils literal notranslate"><span class="pre">atmosphere_end</span></code> subroutine of <code class="docutils literal notranslate"><span class="pre">atmosphere.F90</span></code>. For the rest of the physics, the ‘finalize’ step of the <code class="docutils literal notranslate"><span class="pre">CCPP_step</span></code> subroutine in <code class="docutils literal notranslate"><span class="pre">CCPP_driver.F90</span></code> is called from the <code class="docutils literal notranslate"><span class="pre">atmos_model_end</span></code> subroutine in <code class="docutils literal notranslate"><span class="pre">atmos_model.F90</span></code>. Within the ‘finalize’ step of <code class="docutils literal notranslate"><span class="pre">CCPP_step</span></code>, calls for <code class="docutils literal notranslate"><span class="pre">ccpp_physics_finalize</span></code> and <code class="docutils literal notranslate"><span class="pre">ccpp_finalize</span></code> are executed for every thread and block for <code class="docutils literal notranslate"><span class="pre">cdata_block</span></code>. Afterward, <code class="docutils literal notranslate"><span class="pre">ccpp_finalize</span></code> is called for <code class="docutils literal notranslate"><span class="pre">cdata_domain</span></code> and lastly, <code class="docutils literal notranslate"><span class="pre">cdata_tile</span></code>. (That is, the calls to <code class="docutils literal notranslate"><span class="pre">ccpp_finalize</span></code> are in reverse order than the calls to <code class="docutils literal notranslate"><span class="pre">ccpp_initialize</span></code>.) In addition, <code class="docutils literal notranslate"><span class="pre">cdata_block</span></code> is also deallocated in the ‘finalize’ step of <code class="docutils literal notranslate"><span class="pre">CCPP_step</span></code>.</p></li>
<li><p>Note: for the static mode, <code class="docutils literal notranslate"><span class="pre">ccpp_physics_finalize</span></code> is autogenerated and contained within <code class="docutils literal notranslate"><span class="pre">ccpp_static_api.F90</span></code>. As mentioned in the <a class="reference internal" href="#ccpp-api"><span class="std std-numref">CCPP API Section 6.4</span></a>, it can be called to finalize groups as defined in the current SDFs or the suite as a whole, depending on whether a group name is passed in as an optional argument.</p></li>
</ul>
</div></blockquote>
</div></blockquote>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">6. Host Side Coding</a><ul>
<li><a class="reference internal" href="#variable-requirements-on-the-host-model-side">6.1. Variable Requirements on the Host Model Side</a></li>
<li><a class="reference internal" href="#metadata-for-variable-in-the-host-model">6.2. Metadata for Variable in the Host Model</a></li>
<li><a class="reference internal" href="#ccpp-variables-in-the-scm-and-ufs-atmosphere-host-models">6.3. CCPP Variables in the SCM and UFS Atmosphere Host Models</a></li>
<li><a class="reference internal" href="#ccpp-api">6.4. CCPP API</a><ul>
<li><a class="reference internal" href="#data-structure-to-transfer-variables-between-dynamics-and-physics">6.4.1. Data Structure to Transfer Variables between Dynamics and Physics</a></li>
<li><a class="reference internal" href="#adding-and-retrieving-information-from-cdata-dynamic-build-option">6.4.2. Adding and Retrieving Information from cdata (dynamic build option)</a></li>
<li><a class="reference internal" href="#initializing-and-finalizing-the-ccpp">6.4.3. Initializing and Finalizing the CCPP</a><ul>
<li><a class="reference internal" href="#suite-initialization-subroutine">6.4.3.1. Suite Initialization Subroutine</a></li>
<li><a class="reference internal" href="#suite-finalization-subroutine">6.4.3.2. Suite Finalization Subroutine</a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-the-physics">6.4.4. Running the physics</a></li>
<li><a class="reference internal" href="#initializing-and-finalizing-the-physics">6.4.5. Initializing and Finalizing the Physics</a><ul>
<li><a class="reference internal" href="#subroutine-ccpp-physics-init">6.4.5.1. Subroutine <code class="docutils literal notranslate"><span class="pre">ccpp_physics_init</span></code></a></li>
<li><a class="reference internal" href="#subroutine-ccpp-physics-finalize">6.4.5.2. Subroutine <code class="docutils literal notranslate"><span class="pre">ccpp_physics_finalize</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#host-caps">6.5. Host Caps</a><ul>
<li><a class="reference internal" href="#scm-host-cap">6.5.1. SCM Host Cap</a></li>
<li><a class="reference internal" href="#ufs-atmosphere-host-cap">6.5.2. UFS Atmosphere Host Cap</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="AutoGenPhysCaps.html"
                        title="previous chapter">5. Autogenerated Physics <em>Caps</em></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="CodeManagement.html"
                        title="next chapter">7. CCPP Code Management</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/HostSideCoding.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="CodeManagement.html" title="7. CCPP Code Management"
             >next</a> |</li>
        <li class="right" >
          <a href="AutoGenPhysCaps.html" title="5. Autogenerated Physics Caps"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">CCPP Technical  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019 .
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>